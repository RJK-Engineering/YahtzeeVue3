
Binding
https://vuejs.org/guide/essentials/template-syntax.html

Using text interpolation: {{ msg }}
Raw: <span v-html="rawHtml"></span>
Attribute binding:   <div v-bind:id="dynamicId"></div>
Attribute binding short:   <div :id="dynamicId"></div>
Attribute binding shorter: <div :id></div> (same as: <div :id="id"></div>)

Multiple Attributes:
const objectOfAttrs = {
  id: 'container',
  class: 'wrapper',
  style: 'background-color:green'
}
<div v-bind="objectOfAttrs"></div>

In Vue templates, JavaScript expressions can be used in the following positions:
- Inside text interpolations (mustaches)
- In the attribute value of any Vue directives (special attributes that start with v-)

href is v-bind argument
<a v-bind:href="url">
short:
<a :href="url">

click is v-on argument
<a v-on:click="doSomething">
short:
<a @click="doSomething">

using expressions for arguments (dynamic arguments):
<a :[attibuteName]="url">
<a @[eventName]="doSomething">
(null value removes binding)

Modifiers:
.prevent modifier: <form @submit.prevent="onSubmit">

----------------------
Reactivity
https://vuejs.org/guide/essentials/reactivity-fundamentals.html

const count = ref(0)
console.log(count) 			// { value: 0 }
console.log(count.value) 	// 0
{{ count }}					// 0

The reactive() API has a few limitations:
- Limited value types
- Cannot replace entire object
- Not destructure-friendly
Due to these limitations, we recommend using ref() as the primary API for declaring reactive state.

----------------------
Computed Properties
https://vuejs.org/guide/essentials/computed.html

Opposed to a normal function, a computed property is cached.

Writable computed:
const prop = computed({
  get() {  },
  set(newValue) {  }
})

----------------------
Style binding
https://vuejs.org/guide/essentials/class-and-style.html

Inline:
<div :class="{ active: isActive, 'text-danger': hasError }"></div>

Object:
const classObject = reactive({
  active: true,
  'text-danger': false
})
<div :class="classObject"></div>

Computed:
const classObject = computed(() => ({
  active: isActive.value && !error.value,
  'text-danger': error.value && error.value.type === 'fatal'
}))

Array of bound properties:
<div :class="[activeClass, errorClass]"></div>
Expression:
<div :class="[isActive ? activeClass : '', errorClass]"></div>
=
<div :class="[{ activeClass: isActive }, errorClass]"></div>

When you use the class attribute on a component with a single root element, those classes will be added to the component's root element and merged with any existing class already on it.

----------------------
Conditional
https://vuejs.org/guide/essentials/conditional.html

<div v-if="type === 'A'">
<div v-else-if="type === 'B'">
<div v-else>

<template v-if="ok">

<h1 v-show="ok">
The difference is that an element with v-show will always be rendered and remain in the DOM; v-show only toggles the display CSS property of the element.
Prefer v-show if you need to toggle something very often, and prefer v-if if the condition is unlikely to change at runtime.

When v-if and v-for are both used on the same element, v-if will be evaluated first.

----------------------
Lists/iteration
https://vuejs.org/guide/essentials/list.html

<li v-for="item in items">
<li v-for="(item, index) in items">
<li v-for="value in myObject">
<li v-for="(value, key) in myObject">
<li v-for="(value, key, index) in myObject">
<span v-for="n in 10">
<div v-for="item in items" :key="item.id">
<MyComponent
  v-for="(item, index) in items"
  :item="item"
  :index="index"
  :key="item.id"
/>

Replacing an Array
items.value = items.value.filter((item) => item.message.match(/Foo/))
You might think this will cause Vue to throw away the existing DOM and re-render the entire list - luckily, that is not the case. Vue implements some smart heuristics to maximize DOM element reuse, so replacing an array with another array containing overlapping objects is a very efficient operation.

Computed:
const numbers = ref([1, 2, 3, 4, 5])
const evenNumbers = computed(() => {
  return numbers.value.filter((n) => n % 2 === 0)
})
<li v-for="n in evenNumbers">{{ n }}</li>

Using a function:
const sets = ref([
  [1, 2, 3, 4, 5],
  [6, 7, 8, 9, 10]
])
function even(numbers) {
  return numbers.filter((number) => number % 2 === 0)
}
<ul v-for="numbers in sets">
  <li v-for="n in even(numbers)">{{ n }}</li>
</ul>

Be careful with reverse() and sort() in a computed property! These two methods will mutate the original array, which should be avoided in computed getters. Create a copy of the original array before calling these methods:
- return numbers.reverse()
+ return [...numbers].reverse()

----------------------
Events
https://vuejs.org/guide/essentials/event-handling.html

<button @click="greet">
<button @click="say('hello')">
<button @click="warn('Form cannot be submitted yet.', $event)">
<button @click="(event) => warn('Form cannot be submitted yet.', event)">

Event modifiers:

<!-- the click event's propagation will be stopped -->
<a @click.stop="doThis"></a>

<!-- the submit event will no longer reload the page -->
<form @submit.prevent="onSubmit"></form>

<!-- modifiers can be chained -->
<a @click.stop.prevent="doThat"></a>

<!-- just the modifier -->
<form @submit.prevent></form>

<!-- only trigger handler if event.target is the element itself -->
<!-- i.e. not from a child element -->
<div @click.self="doThat">...</div>

@click.prevent.self will prevent click's default action on the element itself and its children, while
@click.self.prevent will only prevent click's default action on the element itself

The .capture, .once, and .passive modifiers mirror the options of the native addEventListener method:

template
<!-- use capture mode when adding the event listener     -->
<!-- i.e. an event targeting an inner element is handled -->
<!-- here before being handled by that element           -->
<div @click.capture="doThis">...</div>

<!-- the click event will be triggered at most once -->
<a @click.once="doThis"></a>

<!-- the scroll event's default behavior (scrolling) will happen -->
<!-- immediately, instead of waiting for `onScroll` to complete  -->
<!-- in case it contains `event.preventDefault()`                -->
<div @scroll.passive="onScroll">...</div>

Key modifiers:
<input @keyup.enter="submit" />
You can directly use any valid key names exposed via KeyboardEvent.key as modifiers by converting them to kebab-case:
<input @keyup.page-down="onPageDown" />

<!-- Alt + Enter -->
<input @keyup.alt.enter="clear" />
<!-- Ctrl + Click -->
<div @click.ctrl="doSomething">Do something</div>
<!-- this will fire even if Alt or Shift is also pressed -->
<button @click.ctrl="onClick">A</button>
<!-- this will only fire when Ctrl and no other keys are pressed -->
<button @click.ctrl.exact="onCtrlClick">A</button>
<!-- this will only fire when no system modifiers are pressed -->
<button @click.exact="onClick">A</button>
